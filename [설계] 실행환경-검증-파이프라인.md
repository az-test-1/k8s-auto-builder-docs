# 실행환경 검증 파이프라인 설계

> **Status**: Draft
> **Version**: 1.0.0
> **Last Updated**: 2026-01-13
> **Category**: 설계 - Validation

---

## 1. 개요

### 1.1 배경

Auto-Builder는 Java 8→17, Spring Boot 2→3 소스 코드 변환을 수행합니다.
현재 빌드(컴파일) 성공까지는 자동화되어 있으나, **변환된 애플리케이션이 실제로 실행 가능한지** 검증하는 단계가 부재합니다.

```
현재 흐름:
┌──────────┐    ┌───────────┐    ┌───────────┐    ┌──────────┐
│ 소스변환  │ → │ 의존성수정 │ → │ 빌드성공   │ → │ 완료?    │
│ OpenRewrite│   │ LIB_LLM   │    │ BUILD_LLM │    │ (검증無) │
└──────────┘    └───────────┘    └───────────┘    └──────────┘
```

### 1.2 문제점

| 문제 | 영향 | 빈도 |
|------|------|:----:|
| 런타임 에러 미탐지 | 배포 후 장애 | 높음 |
| Bean 초기화 실패 | 앱 시작 불가 | 중간 |
| DB 연결 설정 오류 | 기능 동작 불가 | 중간 |
| 설정 파일 누락/오류 | 앱 시작 불가 | 낮음 |
| API 호환성 깨짐 | 연동 장애 | 중간 |

### 1.3 목표

변환된 애플리케이션의 **실행 가능성**을 자동으로 검증하여:
- 런타임 에러 사전 탐지
- 변환 품질 신뢰도 향상
- 배포 전 위험 요소 제거

---

## 2. 검증 파이프라인 설계

### 2.1 전체 구조

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        실행환경 검증 파이프라인                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐  │
│  │   Phase 1   │    │   Phase 2   │    │   Phase 3   │    │   Phase 4   │  │
│  │   BUILD     │ →  │   PACKAGE   │ →  │   STARTUP   │ →  │    API      │  │
│  │ VALIDATION  │    │ VALIDATION  │    │ VALIDATION  │    │ VALIDATION  │  │
│  └──────┬──────┘    └──────┬──────┘    └──────┬──────┘    └──────┬──────┘  │
│         │                  │                  │                  │         │
│    [필수/자동]          [필수/자동]        [필수/자동]        [선택/자동]    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 Phase 정의

| Phase | 이름 | 목적 | 필수 여부 | 예상 시간 |
|:-----:|------|------|:---------:|:---------:|
| 1 | Build Validation | 컴파일 + 의존성 해결 확인 | 필수 | 1-5분 |
| 2 | Package Validation | JAR/WAR 생성 + 무결성 검증 | 필수 | 1-3분 |
| 3 | Startup Validation | 앱 시작 + Bean 초기화 검증 | 필수 | 1-5분 |
| 4 | API Validation | 엔드포인트 응답 검증 | 선택 | 1-3분 |

---

## 3. Phase 1: Build Validation (빌드 검증)

### 3.1 목적
- 컴파일 성공 여부 확인
- 모든 의존성 해결 확인
- 빌드 경고(Warning) 수집

### 3.2 실행 내용

```python
# validation/build_validator.py
class BuildValidator:
    async def validate(self, context: ValidationContext) -> ValidationResult:
        """
        Phase 1: 빌드 검증
        - 기존 BUILD_LLM 단계와 통합
        - 추가: 경고 수집 및 리포팅
        """
        result = ValidationResult(phase="BUILD")

        # 1. 빌드 실행 (기존 로직 활용)
        build_result = await self.container_manager.run({
            "image": self._get_build_image(),
            "command": self._get_build_command(),  # mvn compile / gradle build
            "timeout": 300,  # 5분
        })

        # 2. 결과 분석
        result.success = build_result.exit_code == 0
        result.errors = self._parse_errors(build_result.output)
        result.warnings = self._parse_warnings(build_result.output)

        # 3. 메트릭 수집
        result.metrics = {
            "compile_time_seconds": build_result.duration,
            "error_count": len(result.errors),
            "warning_count": len(result.warnings),
        }

        return result
```

### 3.3 검증 항목

| 항목 | 검증 방법 | 실패 시 |
|------|----------|---------|
| 컴파일 성공 | exit code == 0 | Phase 종료, LLM 수정 |
| 의존성 해결 | dependency:tree 성공 | Phase 종료, LLM 수정 |
| 심각한 경고 | deprecation 분석 | 경고로 기록 (계속 진행) |

### 3.4 K8s Job 스펙

```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: validate-build-${RUN_ID}
  labels:
    app: auto-builder
    phase: build-validation
spec:
  activeDeadlineSeconds: 600
  backoffLimit: 0
  template:
    spec:
      restartPolicy: Never
      containers:
        - name: build
          image: ${BUILD_IMAGE_REGISTRY}/maven:3.9-eclipse-temurin-17
          command: ["sh", "-c"]
          args:
            - |
              cd /workspace
              mvn clean compile -B -q 2>&1 | tee /output/build.log
              mvn dependency:tree -B 2>&1 | tee /output/deps.log
              echo $? > /output/exit_code
          resources:
            requests:
              memory: "1Gi"
              cpu: "500m"
            limits:
              memory: "4Gi"
              cpu: "2"
          volumeMounts:
            - name: workspace
              mountPath: /workspace
            - name: output
              mountPath: /output
```

---

## 4. Phase 2: Package Validation (패키징 검증)

### 4.1 목적
- 실행 가능한 JAR/WAR 생성 확인
- 패키지 무결성 검증
- 필수 리소스 포함 여부 확인

### 4.2 실행 내용

```python
# validation/package_validator.py
class PackageValidator:
    async def validate(self, context: ValidationContext) -> ValidationResult:
        """
        Phase 2: 패키징 검증
        """
        result = ValidationResult(phase="PACKAGE")

        # 1. 패키징 실행
        package_result = await self.container_manager.run({
            "image": self._get_build_image(),
            "command": "mvn package -DskipTests -B",
            "timeout": 600,  # 10분
        })

        if package_result.exit_code != 0:
            result.success = False
            result.errors = self._parse_errors(package_result.output)
            return result

        # 2. JAR 파일 검증
        jar_check = await self._verify_jar(context.workspace_path)

        # 3. 필수 리소스 검증
        resource_check = await self._verify_resources(context.workspace_path)

        result.success = jar_check.valid and resource_check.valid
        result.details = {
            "jar_path": jar_check.path,
            "jar_size_mb": jar_check.size_mb,
            "main_class": jar_check.main_class,
            "resources": resource_check.found_resources,
            "missing_resources": resource_check.missing,
        }

        return result
```

### 4.3 검증 항목

| 항목 | 검증 방법 | 실패 시 |
|------|----------|---------|
| JAR 생성 | target/*.jar 존재 | Phase 종료 |
| JAR 무결성 | jar -tf 실행 성공 | Phase 종료 |
| Main-Class | MANIFEST.MF 확인 | Phase 종료 |
| application.yml | 리소스 포함 여부 | 경고 |
| 설정 파일 | logback.xml 등 | 경고 |

### 4.4 JAR 검증 스크립트

```bash
#!/bin/bash
# validate_jar.sh

JAR_PATH=$(find target -name "*.jar" -not -name "*-sources.jar" | head -1)

if [ -z "$JAR_PATH" ]; then
    echo "ERROR: JAR file not found"
    exit 1
fi

# JAR 무결성 확인
jar -tf "$JAR_PATH" > /dev/null 2>&1
if [ $? -ne 0 ]; then
    echo "ERROR: JAR file is corrupted"
    exit 1
fi

# Main-Class 확인
MAIN_CLASS=$(unzip -p "$JAR_PATH" META-INF/MANIFEST.MF | grep "Main-Class" | cut -d: -f2 | tr -d ' \r')
if [ -z "$MAIN_CLASS" ]; then
    # Spring Boot executable jar 확인
    MAIN_CLASS=$(unzip -p "$JAR_PATH" META-INF/MANIFEST.MF | grep "Start-Class" | cut -d: -f2 | tr -d ' \r')
fi

if [ -z "$MAIN_CLASS" ]; then
    echo "ERROR: Main-Class not found in MANIFEST.MF"
    exit 1
fi

# 필수 리소스 확인
RESOURCES=("application.yml" "application.yaml" "application.properties")
FOUND=0
for res in "${RESOURCES[@]}"; do
    if unzip -l "$JAR_PATH" | grep -q "$res"; then
        FOUND=1
        echo "INFO: Found $res"
    fi
done

if [ $FOUND -eq 0 ]; then
    echo "WARNING: No application config file found"
fi

echo "SUCCESS: JAR validation passed"
echo "JAR_PATH=$JAR_PATH"
echo "MAIN_CLASS=$MAIN_CLASS"
echo "JAR_SIZE=$(du -h "$JAR_PATH" | cut -f1)"
```

---

## 5. Phase 3: Startup Validation (시작 검증)

### 5.1 목적
- 애플리케이션 정상 시작 확인
- Spring Context 초기화 검증
- Bean 생성 오류 탐지
- Health Check 응답 확인

### 5.2 실행 내용

```python
# validation/startup_validator.py
class StartupValidator:
    STARTUP_TIMEOUT = 120  # 2분
    HEALTH_CHECK_INTERVAL = 5  # 5초

    async def validate(self, context: ValidationContext) -> ValidationResult:
        """
        Phase 3: 시작 검증
        - 앱 컨테이너 시작
        - Health endpoint 폴링
        - 로그 분석
        """
        result = ValidationResult(phase="STARTUP")

        # 1. 검증용 컨테이너 시작 (Mock 의존성 포함)
        container_id = await self._start_validation_container(context)

        try:
            # 2. 시작 대기 + Health Check
            started = await self._wait_for_startup(
                container_id,
                timeout=self.STARTUP_TIMEOUT
            )

            # 3. 로그 수집 및 분석
            logs = await self._collect_logs(container_id)
            startup_analysis = self._analyze_startup_logs(logs)

            result.success = started and not startup_analysis.has_errors
            result.details = {
                "startup_time_seconds": startup_analysis.startup_time,
                "beans_loaded": startup_analysis.beans_count,
                "active_profiles": startup_analysis.profiles,
                "warnings": startup_analysis.warnings,
                "errors": startup_analysis.errors,
            }

        finally:
            # 4. 컨테이너 정리
            await self._cleanup_container(container_id)

        return result

    async def _wait_for_startup(self, container_id: str, timeout: int) -> bool:
        """Health endpoint 폴링으로 시작 확인"""
        start_time = time.time()

        while time.time() - start_time < timeout:
            try:
                response = await self._health_check(container_id)
                if response.status == "UP":
                    return True
            except Exception:
                pass

            await asyncio.sleep(self.HEALTH_CHECK_INTERVAL)

        return False
```

### 5.3 검증 항목

| 항목 | 검증 방법 | 실패 시 |
|------|----------|---------|
| 프로세스 시작 | PID 존재 확인 | Phase 종료 |
| Spring Context | ApplicationContext 초기화 로그 | Phase 종료 |
| Bean 초기화 | 에러 로그 없음 | Phase 종료, 상세 리포트 |
| Health Check | /actuator/health 응답 | Phase 종료 |
| 시작 시간 | < 2분 | 경고 |

### 5.4 Mock 의존성 구성

실행환경 검증을 위해 외부 의존성을 Mock으로 대체합니다.

```yaml
# validation-compose.yaml
version: '3.8'
services:
  # 검증 대상 앱
  app:
    image: ${APP_IMAGE}
    environment:
      - SPRING_PROFILES_ACTIVE=validation
      - SPRING_DATASOURCE_URL=jdbc:postgresql://mock-db:5432/test
      - SPRING_REDIS_HOST=mock-redis
    depends_on:
      - mock-db
      - mock-redis
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/actuator/health"]
      interval: 5s
      timeout: 10s
      retries: 24  # 2분
      start_period: 10s

  # Mock PostgreSQL
  mock-db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=test
      - POSTGRES_USER=test
      - POSTGRES_PASSWORD=test
    tmpfs:
      - /var/lib/postgresql/data  # 임시 데이터

  # Mock Redis
  mock-redis:
    image: redis:7-alpine
    command: redis-server --save ""  # 영속성 비활성화
```

### 5.5 K8s Pod 스펙 (Sidecar 패턴)

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: validate-startup-${RUN_ID}
  labels:
    app: auto-builder
    phase: startup-validation
spec:
  restartPolicy: Never
  initContainers:
    # JAR 복사
    - name: copy-jar
      image: busybox
      command: ["cp", "/source/target/*.jar", "/app/app.jar"]
      volumeMounts:
        - name: source
          mountPath: /source
        - name: app
          mountPath: /app

  containers:
    # 검증 대상 앱
    - name: app
      image: ${BUILD_IMAGE_REGISTRY}/eclipse-temurin:17-jre
      command: ["java", "-jar", "/app/app.jar"]
      env:
        - name: SPRING_PROFILES_ACTIVE
          value: "validation"
        - name: SPRING_DATASOURCE_URL
          value: "jdbc:postgresql://localhost:5432/test"
        - name: SPRING_REDIS_HOST
          value: "localhost"
      ports:
        - containerPort: 8080
      readinessProbe:
        httpGet:
          path: /actuator/health
          port: 8080
        initialDelaySeconds: 10
        periodSeconds: 5
        failureThreshold: 24  # 2분
      resources:
        requests:
          memory: "512Mi"
          cpu: "250m"
        limits:
          memory: "2Gi"
          cpu: "1"
      volumeMounts:
        - name: app
          mountPath: /app

    # Sidecar: Mock PostgreSQL
    - name: mock-db
      image: postgres:15-alpine
      env:
        - name: POSTGRES_DB
          value: "test"
        - name: POSTGRES_USER
          value: "test"
        - name: POSTGRES_PASSWORD
          value: "test"
      resources:
        requests:
          memory: "128Mi"
          cpu: "100m"
        limits:
          memory: "256Mi"
          cpu: "200m"

    # Sidecar: Mock Redis
    - name: mock-redis
      image: redis:7-alpine
      args: ["--save", ""]
      resources:
        requests:
          memory: "64Mi"
          cpu: "50m"
        limits:
          memory: "128Mi"
          cpu: "100m"

  volumes:
    - name: source
      persistentVolumeClaim:
        claimName: ${K8S_DATA_PVC_NAME}
    - name: app
      emptyDir: {}
```

### 5.6 시작 로그 분석

```python
# validation/log_analyzer.py
class StartupLogAnalyzer:
    # Spring Boot 시작 성공 패턴
    SUCCESS_PATTERNS = [
        r"Started \w+ in [\d.]+ seconds",
        r"Tomcat started on port",
        r"Netty started on port",
    ]

    # 치명적 에러 패턴
    ERROR_PATTERNS = [
        r"APPLICATION FAILED TO START",
        r"BeanCreationException",
        r"NoSuchBeanDefinitionException",
        r"UnsatisfiedDependencyException",
        r"BeanCurrentlyInCreationException",
        r"CannotLoadBeanClassException",
        r"java\.lang\.NoClassDefFoundError",
        r"java\.lang\.ClassNotFoundException",
    ]

    # 경고 패턴
    WARNING_PATTERNS = [
        r"@Deprecated",
        r"HikariPool.*Connection is not available",
        r"Table .* doesn't exist",
    ]

    def analyze(self, logs: str) -> StartupAnalysis:
        result = StartupAnalysis()

        # 시작 성공 여부
        for pattern in self.SUCCESS_PATTERNS:
            if match := re.search(pattern, logs):
                result.started = True
                result.startup_message = match.group(0)
                break

        # 에러 추출
        for pattern in self.ERROR_PATTERNS:
            matches = re.findall(pattern, logs)
            result.errors.extend(matches)

        # 경고 추출
        for pattern in self.WARNING_PATTERNS:
            matches = re.findall(pattern, logs)
            result.warnings.extend(matches)

        # 시작 시간 추출
        if match := re.search(r"Started \w+ in ([\d.]+) seconds", logs):
            result.startup_time = float(match.group(1))

        # Bean 수 추출
        if match := re.search(r"(\d+) beans", logs):
            result.beans_count = int(match.group(1))

        return result
```

---

## 6. Phase 4: API Validation (API 검증) [선택]

### 6.1 목적
- 주요 API 엔드포인트 응답 확인
- 응답 스키마 호환성 검증
- 기본적인 기능 동작 확인

### 6.2 실행 내용

```python
# validation/api_validator.py
class ApiValidator:
    async def validate(self, context: ValidationContext) -> ValidationResult:
        """
        Phase 4: API 검증 (선택적)
        - 자동 엔드포인트 탐지
        - 기본 응답 검증
        """
        result = ValidationResult(phase="API")

        # 1. 엔드포인트 목록 수집 (Actuator mappings 활용)
        endpoints = await self._discover_endpoints(context)

        # 2. 각 엔드포인트 테스트
        test_results = []
        for endpoint in endpoints:
            if endpoint.method == "GET" and not endpoint.requires_auth:
                test_result = await self._test_endpoint(endpoint)
                test_results.append(test_result)

        # 3. 결과 집계
        passed = sum(1 for r in test_results if r.success)
        failed = sum(1 for r in test_results if not r.success)

        result.success = failed == 0
        result.details = {
            "total_endpoints": len(endpoints),
            "tested": len(test_results),
            "passed": passed,
            "failed": failed,
            "results": test_results,
        }

        return result

    async def _discover_endpoints(self, context) -> List[Endpoint]:
        """Actuator mappings에서 엔드포인트 자동 탐지"""
        response = await self._call(
            f"http://localhost:{context.port}/actuator/mappings"
        )

        endpoints = []
        for mapping in response.get("contexts", {}).values():
            for handler in mapping.get("mappings", {}).get("dispatcherServlets", {}).values():
                for item in handler:
                    endpoints.append(self._parse_mapping(item))

        return endpoints
```

### 6.3 검증 항목

| 항목 | 검증 방법 | 실패 시 |
|------|----------|---------|
| Actuator endpoints | /actuator/* 응답 | 경고 |
| Health endpoint | 200 + UP 상태 | 경고 |
| Info endpoint | 200 응답 | 경고 |
| GET endpoints | 4xx/5xx 없음 | 경고 (상세 리포트) |

### 6.4 자동 테스트 생성 (LLM 활용)

```python
# validation/api_test_generator.py
class ApiTestGenerator:
    async def generate_tests(self, context: ValidationContext) -> List[ApiTest]:
        """LLM을 활용한 API 테스트 자동 생성"""

        # 1. Controller 클래스 분석
        controllers = await self._find_controllers(context.workspace_path)

        # 2. LLM에게 테스트 생성 요청
        prompt = f"""
        다음 Spring Controller를 분석하고 간단한 API 테스트를 생성해주세요.

        ## Controller 코드
        {controllers}

        ## 요구사항
        - GET 엔드포인트만 테스트
        - 인증이 필요 없는 엔드포인트만
        - 기본적인 200 응답 확인
        - JSON 형식으로 테스트 케이스 출력
        """

        response = await self.llm_manager.generate(prompt)
        return self._parse_test_cases(response)
```

### 6.5 인증 처리 방안

API 검증 시 인증이 필요한 엔드포인트 처리 전략입니다.

#### 6.5.1 인증 처리 옵션

| 옵션 | 방식 | 난이도 | 커버리지 | 권장 |
|:----:|------|:------:|:--------:|:----:|
| A | Public API만 테스트 | 쉬움 | 낮음 | MVP |
| B | Validation Profile 우회 | 중간 | 높음 | **1차** |
| C | JWT 토큰 자동 생성 | 중간 | 높음 | 2차 |
| D | Mock Auth Server | 어려움 | 매우 높음 | 선택 |

#### 6.5.2 옵션 B: Validation Profile Security 우회 (권장)

```yaml
# application-validation.yml
spring:
  profiles: validation
  security:
    enabled: false
```

```java
// ValidationSecurityConfig.java
@Configuration
@Profile("validation")
public class ValidationSecurityConfig {

    @Bean
    public SecurityFilterChain validationFilterChain(HttpSecurity http) throws Exception {
        return http
            .authorizeHttpRequests(auth -> auth
                .anyRequest().permitAll()
            )
            .csrf(csrf -> csrf.disable())
            .build();
    }
}
```

> **주의**: 이 설정은 `validation` 프로필에서만 활성화되며, 프로덕션에는 영향 없음

#### 6.5.3 옵션 C: JWT 토큰 자동 생성

```python
# validation/auth_provider.py
class ValidationAuthProvider:
    """검증용 인증 토큰 생성"""

    async def get_test_token(self, context: ValidationContext) -> str:
        # 1. 앱의 JWT 설정 추출 (application.yml에서)
        jwt_secret = await self._extract_jwt_secret(context)

        # 2. 테스트 토큰 생성
        payload = {
            "sub": "validation-user",
            "roles": ["ADMIN", "USER"],
            "exp": datetime.utcnow() + timedelta(hours=1),
            "iat": datetime.utcnow(),
        }

        return jwt.encode(payload, jwt_secret, algorithm="HS256")

    async def _extract_jwt_secret(self, context: ValidationContext) -> str:
        """application.yml에서 JWT secret 추출"""
        config_path = f"{context.workspace_path}/src/main/resources/application.yml"
        config = yaml.safe_load(open(config_path))

        # jwt.secret 또는 spring.security.jwt.secret 등 다양한 경로 탐색
        return (
            config.get("jwt", {}).get("secret") or
            config.get("spring", {}).get("security", {}).get("jwt", {}).get("secret") or
            config.get("app", {}).get("jwt-secret")
        )
```

```python
# API 호출 시 토큰 적용
class ApiValidator:
    async def _test_endpoint(self, endpoint: Endpoint) -> TestResult:
        headers = {"Content-Type": "application/json"}

        if endpoint.requires_auth:
            token = await self.auth_provider.get_test_token(self.context)
            headers["Authorization"] = f"Bearer {token}"

        response = await self.http_client.request(
            method=endpoint.method,
            url=endpoint.url,
            headers=headers,
            timeout=10
        )

        return TestResult(
            endpoint=endpoint,
            status_code=response.status_code,
            success=response.status_code < 400,
            response_time_ms=response.elapsed_ms
        )
```

#### 6.5.4 옵션 D: Mock 인증 서버 (Sidecar)

OAuth2/OIDC 흐름이 필요한 경우 WireMock을 Sidecar로 배포합니다.

```yaml
# K8s Pod - Mock Auth Server 추가
containers:
  - name: app
    env:
      - name: SPRING_SECURITY_OAUTH2_RESOURCESERVER_JWT_ISSUER_URI
        value: "http://localhost:9000"

  - name: mock-auth
    image: wiremock/wiremock:latest
    args: ["--port=9000"]
    volumeMounts:
      - name: wiremock-stubs
        mountPath: /home/wiremock/mappings

volumes:
  - name: wiremock-stubs
    configMap:
      name: mock-auth-stubs
```

```yaml
# ConfigMap: mock-auth-stubs
apiVersion: v1
kind: ConfigMap
metadata:
  name: mock-auth-stubs
data:
  token.json: |
    {
      "request": {
        "method": "POST",
        "url": "/oauth/token"
      },
      "response": {
        "status": 200,
        "headers": {"Content-Type": "application/json"},
        "jsonBody": {
          "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
          "token_type": "Bearer",
          "expires_in": 3600
        }
      }
    }
  jwks.json: |
    {
      "request": {
        "method": "GET",
        "url": "/.well-known/jwks.json"
      },
      "response": {
        "status": 200,
        "headers": {"Content-Type": "application/json"},
        "jsonBody": {
          "keys": [{"kty": "RSA", "kid": "test-key", ...}]
        }
      }
    }
```

#### 6.5.5 하이브리드 전략 (권장 구현)

```python
class ApiValidator:
    """하이브리드 인증 전략을 적용한 API 검증"""

    async def validate(self, context: ValidationContext) -> ValidationResult:
        endpoints = await self._discover_endpoints(context)
        auth_mode = context.settings.get("VALIDATION_AUTH_MODE", "hybrid")

        results = []

        # Phase A: Public API 테스트 (항상 실행)
        public_endpoints = [e for e in endpoints if not e.requires_auth]
        for ep in public_endpoints:
            results.append(await self._test_endpoint(ep))

        # Phase B: 인증 필요 API 처리
        auth_endpoints = [e for e in endpoints if e.requires_auth]

        if auth_mode == "skip":
            # 인증 API 스킵
            for ep in auth_endpoints:
                results.append(TestResult(ep, skipped=True, reason="auth_required"))

        elif auth_mode == "bypass":
            # Validation Profile로 Security 우회 (앱 재시작 필요)
            await self._restart_with_validation_profile(context)
            for ep in auth_endpoints:
                results.append(await self._test_endpoint(ep))

        elif auth_mode == "token":
            # JWT 토큰 생성하여 테스트
            token = await self.auth_provider.get_test_token(context)
            for ep in auth_endpoints:
                results.append(await self._test_endpoint(ep, token=token))

        elif auth_mode == "hybrid":
            # 토큰 생성 시도, 실패 시 스킵
            try:
                token = await self.auth_provider.get_test_token(context)
                for ep in auth_endpoints:
                    results.append(await self._test_endpoint(ep, token=token))
            except Exception as e:
                self.logger.warning(f"Token generation failed: {e}, skipping auth endpoints")
                for ep in auth_endpoints:
                    results.append(TestResult(ep, skipped=True, reason=str(e)))

        return self._aggregate_results(results)
```

#### 6.5.6 인증 관련 환경 변수

| 변수명 | 설명 | 기본값 | 옵션 |
|--------|------|--------|------|
| `VALIDATION_AUTH_MODE` | 인증 처리 모드 | `hybrid` | `skip`, `bypass`, `token`, `hybrid` |
| `VALIDATION_AUTH_ROLES` | 테스트 토큰 역할 | `ADMIN,USER` | 쉼표 구분 |
| `VALIDATION_AUTH_SKIP_PATTERNS` | 스킵할 경로 패턴 | `/admin/*` | 쉼표 구분 |
| `VALIDATION_JWT_SECRET_PATH` | JWT Secret 경로 | `jwt.secret` | YAML 경로 |

#### 6.5.7 인증 처리 흐름도

```
┌─────────────────────────────────────────────────────────────────┐
│                    API 검증 인증 처리 흐름                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────────────┐                                          │
│  │ 엔드포인트 탐지   │                                          │
│  └────────┬─────────┘                                          │
│           │                                                     │
│           ▼                                                     │
│  ┌──────────────────┐    Yes    ┌──────────────────┐           │
│  │ 인증 필요 여부?   │─────────→│ AUTH_MODE 확인    │           │
│  └────────┬─────────┘           └────────┬─────────┘           │
│           │ No                           │                      │
│           ▼                              ▼                      │
│  ┌──────────────────┐    ┌───────────────────────────────────┐ │
│  │ 직접 테스트      │    │  skip    → 스킵 (결과에 기록)      │ │
│  └──────────────────┘    │  bypass  → Profile 우회 후 테스트  │ │
│                          │  token   → JWT 생성 후 테스트      │ │
│                          │  hybrid  → 토큰 시도, 실패시 스킵   │ │
│                          └───────────────────────────────────┘ │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 7. 전체 파이프라인 통합

### 7.1 새로운 Step 추가

```python
# tr_run_step_model.py
class StepType(str, Enum):
    SETUP_PROJECT = "SETUP_PROJECT"
    OPENREWRITE = "OPENREWRITE"
    SQL = "SQL"
    BUILD_LLM = "BUILD_LLM"
    VALIDATE = "VALIDATE"  # 신규 추가
    FEW_SHOT_GENERATE = "FEW_SHOT_GENERATE"
```

### 7.2 Validation Executor

```python
# step_executors/validation_executor.py
class ValidationExecutor(BaseStepExecutor):
    """실행환경 검증 Executor"""

    async def run(self) -> bool:
        validators = [
            BuildValidator(),      # Phase 1
            PackageValidator(),    # Phase 2
            StartupValidator(),    # Phase 3
        ]

        # API Validation은 설정에 따라 선택적
        if self.context.settings.get("enable_api_validation"):
            validators.append(ApiValidator())  # Phase 4

        results = []
        for validator in validators:
            result = await validator.validate(self.context)
            results.append(result)

            # 각 Phase 완료 후 상태 저장
            await self._save_phase_result(result)

            # 필수 Phase 실패 시 중단
            if not result.success and result.is_required:
                self.context.validation_failed = True
                break

        # 전체 결과 집계
        return all(r.success for r in results if r.is_required)
```

### 7.3 실행 흐름

```
기존 흐름:
SETUP → OPENREWRITE → SQL → BUILD_LLM → FEW_SHOT

신규 흐름:
SETUP → OPENREWRITE → SQL → BUILD_LLM → VALIDATE → FEW_SHOT
                                            │
                                   ┌────────┼────────┐
                                   ↓        ↓        ↓
                              Phase 1  Phase 2  Phase 3  [Phase 4]
                              BUILD    PACKAGE  STARTUP  API
```

---

## 8. 환경 구성

### 8.1 새로운 환경 변수

| 변수명 | 설명 | 기본값 |
|--------|------|--------|
| `VALIDATION_ENABLED` | 검증 파이프라인 활성화 | `true` |
| `VALIDATION_STARTUP_TIMEOUT` | 시작 검증 타임아웃 (초) | `120` |
| `VALIDATION_HEALTH_ENDPOINT` | Health check 경로 | `/actuator/health` |
| `VALIDATION_API_ENABLED` | API 검증 활성화 | `false` |
| `VALIDATION_MOCK_DB_IMAGE` | Mock DB 이미지 | `postgres:15-alpine` |
| `VALIDATION_MOCK_REDIS_IMAGE` | Mock Redis 이미지 | `redis:7-alpine` |

### 8.2 ConfigMap 추가

```yaml
# kubernetes/base/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: cms-validation-config
data:
  VALIDATION_ENABLED: "true"
  VALIDATION_STARTUP_TIMEOUT: "120"
  VALIDATION_HEALTH_ENDPOINT: "/actuator/health"
  VALIDATION_API_ENABLED: "false"
```

### 8.3 Validation Profile (application-validation.yml)

```yaml
# 검증용 Spring Profile
spring:
  profiles: validation

  # 외부 서비스 비활성화
  cloud:
    discovery:
      enabled: false

  # Mock 데이터소스
  datasource:
    url: jdbc:postgresql://localhost:5432/test
    username: test
    password: test
    hikari:
      maximum-pool-size: 2
      connection-timeout: 5000

  # Mock Redis
  redis:
    host: localhost
    port: 6379

  # 캐시 비활성화
  cache:
    type: none

# Actuator 활성화
management:
  endpoints:
    web:
      exposure:
        include: health,info,mappings
  endpoint:
    health:
      show-details: always
```

---

## 9. 결과 리포팅

### 9.1 ValidationReport 모델

```python
@dataclass
class ValidationReport:
    run_id: str
    timestamp: datetime
    overall_status: str  # PASSED, FAILED, WARNING
    phases: List[PhaseResult]

    # 요약
    total_phases: int
    passed_phases: int
    failed_phases: int

    # 상세
    errors: List[ValidationError]
    warnings: List[ValidationWarning]
    metrics: Dict[str, Any]

    # 권장 사항
    recommendations: List[str]
```

### 9.2 리포트 예시

```json
{
  "run_id": "tr-run-12345",
  "timestamp": "2026-01-13T15:30:00Z",
  "overall_status": "PASSED",
  "summary": {
    "total_phases": 4,
    "passed": 4,
    "failed": 0,
    "warnings": 2
  },
  "phases": [
    {
      "phase": "BUILD",
      "status": "PASSED",
      "duration_seconds": 45,
      "details": {
        "compile_time": 42,
        "error_count": 0,
        "warning_count": 3
      }
    },
    {
      "phase": "PACKAGE",
      "status": "PASSED",
      "duration_seconds": 30,
      "details": {
        "jar_path": "target/app-1.0.0.jar",
        "jar_size_mb": 45.2,
        "main_class": "com.example.Application"
      }
    },
    {
      "phase": "STARTUP",
      "status": "PASSED",
      "duration_seconds": 25,
      "details": {
        "startup_time": 8.5,
        "beans_loaded": 312,
        "active_profiles": ["validation"],
        "health_status": "UP"
      }
    },
    {
      "phase": "API",
      "status": "PASSED",
      "duration_seconds": 15,
      "details": {
        "endpoints_tested": 5,
        "passed": 5,
        "failed": 0
      }
    }
  ],
  "warnings": [
    {
      "phase": "BUILD",
      "message": "3 deprecated API usages found"
    },
    {
      "phase": "STARTUP",
      "message": "HikariPool connection warning"
    }
  ],
  "recommendations": [
    "Consider updating deprecated APIs before production deployment",
    "Review HikariPool configuration for production"
  ]
}
```

---

## 10. 에러 처리 및 복구

### 10.1 Phase별 실패 처리

```python
class ValidationErrorHandler:
    async def handle_failure(
        self,
        phase: str,
        error: ValidationError,
        context: ValidationContext
    ) -> RecoveryAction:

        if phase == "BUILD":
            # 빌드 실패 → LLM 수정 재시도
            return RecoveryAction.RETRY_WITH_LLM

        elif phase == "PACKAGE":
            # 패키징 실패 → 설정 검토 필요
            return RecoveryAction.MANUAL_REVIEW

        elif phase == "STARTUP":
            # 시작 실패 → 로그 분석 후 LLM 수정
            if self._is_bean_error(error):
                return RecoveryAction.RETRY_WITH_LLM
            else:
                return RecoveryAction.MANUAL_REVIEW

        elif phase == "API":
            # API 실패 → 경고로 처리 (선택적)
            return RecoveryAction.WARN_AND_CONTINUE
```

### 10.2 자동 복구 전략

| 에러 유형 | 복구 전략 | 최대 재시도 |
|----------|----------|:-----------:|
| 컴파일 에러 | LLM 수정 | 5회 |
| Bean 초기화 실패 | LLM 수정 + 프로필 조정 | 3회 |
| 의존성 누락 | LLM 의존성 추가 | 3회 |
| 설정 오류 | LLM 설정 수정 | 3회 |
| 런타임 에러 | 수동 검토 | 0회 |

---

## 11. 구현 계획

### 11.1 Phase 1 (MVP)

- [ ] ValidationExecutor 기본 구조
- [ ] BuildValidator (기존 BUILD_LLM 통합)
- [ ] PackageValidator
- [ ] StartupValidator (기본 Health Check)
- [ ] K8s Pod 스펙 (Sidecar 패턴)
- [ ] ValidationReport 모델

### 11.2 Phase 2

- [ ] 상세 로그 분석기
- [ ] Mock 의존성 자동 구성
- [ ] 검증 실패 시 LLM 자동 수정
- [ ] 검증 결과 UI 표시

### 11.3 Phase 3

- [ ] ApiValidator
- [ ] LLM 기반 테스트 자동 생성
- [ ] 메트릭 수집 및 대시보드
- [ ] 검증 히스토리 분석

---

## 12. 리소스 요구사항

### 12.1 추가 리소스

| 구성요소 | CPU | Memory | 비고 |
|----------|:---:|:------:|------|
| 검증 Pod (앱) | 1 core | 2Gi | 시작 검증용 |
| Mock DB | 200m | 256Mi | Sidecar |
| Mock Redis | 100m | 128Mi | Sidecar |
| **총 추가** | **1.3 cores** | **2.4Gi** | per validation |

### 12.2 예상 실행 시간

| Phase | 예상 시간 | 비고 |
|-------|:--------:|------|
| BUILD | 1-5분 | 프로젝트 크기 의존 |
| PACKAGE | 1-3분 | 프로젝트 크기 의존 |
| STARTUP | 0.5-2분 | 앱 복잡도 의존 |
| API | 0.5-1분 | 엔드포인트 수 의존 |
| **총 추가** | **3-11분** | 기존 대비 |

---

## 13. 관련 문서

- [유즈케이스-Java8to17-실행흐름](./%5B분석%5D%20유즈케이스-Java8to17-실행흐름.md)
- [PRD-020-AI-LLM](./prd/PRD-020-AI-LLM.md)
- [ADR-M010-빌드-Job-실행-방식](./adr/M010-빌드-Job-실행-방식.md)
- [ADR-M011-고가용성-전략](./adr/M011-고가용성-전략-HPA-PDB.md)

---

## 변경 이력

| 버전 | 날짜 | 작성자 | 변경 내용 |
|------|------|--------|----------|
| 1.0.0 | 2026-01-13 | - | 초안 작성 |
